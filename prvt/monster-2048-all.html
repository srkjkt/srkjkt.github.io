<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 게임 + 그리드 기반 몬스터</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <style>
body{font-family:Arial,sans-serif;display:flex;justify-content:center;align-items:center;height:100vh;margin:0;background-color:#faf8ef}#game-wrapper{display:flex;flex-direction:column;align-items:center;position:relative}#score,#lowest-monster{font-size:24px;margin-bottom:20px}#monster-area,#game-container{width:400px;height:400px;background-color:#bbada0;border-radius:5px;position:relative;margin-bottom:20px}#monster-area{display:grid;grid-template-columns:repeat(16,1fr);grid-template-rows:repeat(16,1fr);gap:1px;padding:1px;box-sizing:border-box}.monster-tile{background-color:#cdc1b4;width:100%;height:100%}#game-container{display:grid;grid-template-columns:repeat(4,1fr);grid-template-rows:repeat(4,1fr);gap:15px;padding:15px;box-sizing:border-box}.tile{background-color:#cdc1b4;display:flex;justify-content:center;align-items:center;font-size:36px;font-weight:bold;border-radius:3px;color:#776e65}.tile:empty{background-color:#cdc1b4}.monster{width:100%;height:100%;position:relative;z-index:1;transition:all .3s ease}.hp-bar{position:absolute;bottom:-2px;left:0;width:100%;height:2px;background-color:#27ae60;transition:width .3s ease}#game-over{position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(238,228,218,0.73);display:none;justify-content:center;align-items:center;font-size:48px;font-weight:bold;color:#776e65;z-index:1000;text-shadow:2px 2px 4px rgba(0,0,0,0.1)}button{display:inline-block;margin:10px;padding:10px 20px;font-size:18px;background-color:#8f7a66;color:white;border:none;border-radius:5px;cursor:pointer;transition:background-color .3s ease}button:hover{background-color:#9f8a76}.fire-monster{width:100%;height:100%}
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="score">점수: 0</div>
        <div id="monster-area"></div>
        <div id="lowest-monster">가장 아래 몬스터: 없음</div>
        <div id="game-container"></div>
        <div id="game-over">게임 오버</div>
        <button id="restart">게임 재시작</button>
    </div>

    <script>
    $(document).ready(() => {
        let grid = [];
        let score = 0;
        let monsters = [];
        let isGameActive = true;

        const monsterTypes = [
            { name: '물', color: '#3498db' },
            { name: '불', color: '#e74c3c', shape: 'fire' },
            { name: '흙', color: '#8B4513' },
            { name: '바람', color: '#7FB3D5' }
        ];

        const createFireSVG = () => `
            <svg class="fire-monster" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <path fill="#e74c3c" d="M50 10 C55 25 65 30 70 40 Q80 60 70 80 Q60 90 50 90 Q40 90 30 80 Q20 60 30 40 C35 30 45 25 50 10z">
                    <animate attributeName="d" dur="1.5s" repeatCount="indefinite" values="
                        M50 10 C55 25 65 30 70 40 Q80 60 70 80 Q60 90 50 90 Q40 90 30 80 Q20 60 30 40 C35 30 45 25 50 10z;
                        M50 10 C60 25 70 30 75 40 Q85 60 75 80 Q65 90 50 90 Q35 90 25 80 Q15 60 25 40 C30 30 40 25 50 10z;
                        M50 10 C55 25 65 30 70 40 Q80 60 70 80 Q60 90 50 90 Q40 90 30 80 Q20 60 30 40 C35 30 45 25 50 10z"
                    />
                </path>
            </svg>
        `;

        const initGame = () => {
            grid = Array(4).fill().map(() => Array(4).fill(0));
            score = 0;
            monsters = [];
            isGameActive = true;
            addRandomTile();
            addRandomTile();
            renderGrid();
            renderMonsterArea();
            renderMonsters();
            $('#game-over').hide();
            updateScore();
            updateLowestMonster();
        };

        const addRandomTile = () => {
            const availableCells = [];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (grid[i][j] === 0) {
                        availableCells.push({x: i, y: j});
                    }
                }
            }
            if (availableCells.length > 0) {
                const {x, y} = availableCells[Math.floor(Math.random() * availableCells.length)];
                grid[x][y] = Math.random() < 0.9 ? 2 : 4;
            }
        };

        const renderGrid = () => {
            $('#game-container').empty();
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const $tile = $('<div>').addClass('tile');
                    if (grid[i][j] !== 0) {
                        $tile.text(grid[i][j])
                            .css({
                                'background-color': getTileColor(grid[i][j]),
                                'color': grid[i][j] > 4 ? '#f9f6f2' : '#776e65',
                                'font-size': getFontSize(grid[i][j])
                            });
                    }
                    $('#game-container').append($tile);
                }
            }
        };

        const renderMonsterArea = () => {
            $('#monster-area').empty();
            for (let i = 0; i < 16; i++) {
                for (let j = 0; j < 16; j++) {
                    $('<div>').addClass('monster-tile').appendTo('#monster-area');
                }
            }
        };

        const getTileColor = (value) => {
            const colors = {
                2: '#eee4da', 4: '#ede0c8', 8: '#f2b179', 16: '#f59563',
                32: '#f67c5f', 64: '#f65e3b', 128: '#edcf72', 256: '#edcc61',
                512: '#edc850', 1024: '#edc53f', 2048: '#edc22e', 4096: '#3c3a32',
                8192: '#2c2a24', 16384: '#1c1a16', 32768: '#0c0a08', 65536: '#000000'
            };
            return colors[value] || '#000000';
        };

        const getFontSize = (value) => {
            const sizes = {
                2: '36px', 4: '36px', 8: '36px', 16: '36px', 32: '36px',
                64: '34px', 128: '30px', 256: '28px', 512: '26px',
                1024: '24px', 2048: '22px', 4096: '20px', 8192: '18px',
                16384: '16px', 32768: '14px', 65536: '12px'
            };
            return sizes[value] || '12px';
        };

        const moveLeft = () => {
            let moved = false;
            let mergeScore = 0;
            for (let i = 0; i < 4; i++) {
                let row = grid[i].filter(x => x !== 0);
                let newRow = [];
                for (let j = 0; j < row.length; j++) {
                    if (j < row.length - 1 && row[j] === row[j + 1]) {
                        newRow.push(row[j] * 2);
                        mergeScore += row[j] * 2;
                        j++;
                    } else {
                        newRow.push(row[j]);
                    }
                }
                while (newRow.length < 4) newRow.push(0);
                if (newRow.join(',') !== grid[i].join(',')) {
                    moved = true;
                }
                grid[i] = newRow;
            }
            score += mergeScore;
            return { moved, mergeScore };
        };

        const rotate = (grid) => grid[0].map((_, i) => grid.map(row => row[i]).reverse());

        const move = (direction) => {
            if (!isGameActive) return;

            let rotations = 0;
            switch (direction) {
                case 'ArrowUp': rotations = 3; break;
                case 'ArrowRight': rotations = 2; break;
                case 'ArrowDown': rotations = 1; break;
            }

            for (let i = 0; i < rotations; i++) {
                grid = rotate(grid);
            }

            const { moved, mergeScore } = moveLeft();

            for (let i = 0; i < (4 - rotations) % 4; i++) {
                grid = rotate(grid);
            }

            if (moved) {
                addRandomTile();
                renderGrid();
                updateScore();
                updateMonsters(mergeScore);
                spawnMonster();
                renderMonsters();
                updateLowestMonster();
                
                if (is2048GameOver() || isMonsterGameOver()) {
                    endGame();
                }
            } else if (is2048GameOver()) {
                endGame();
            }
        };

        const is2048GameOver = () => {
            if (grid.some(row => row.includes(0))) {
                return false;
            }

            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (
                        (j < 3 && grid[i][j] === grid[i][j + 1]) ||
                        (i < 3 && grid[i][j] === grid[i + 1][j])
                    ) {
                        return false;
                    }
                }
            }

            return true;
        };

        const updateScore = () => {
            $('#score').text(`점수: ${score}`);
        };

        const spawnMonster = () => {
            const x = Math.floor(Math.random() * 16);
            const type = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];
            const speed = Math.random() * (1 - 0.3) + 0.3;
            monsters.push({ id: Date.now(), x, y: 0, hp: 100, type, speed, accumulatedSpeed: 0 });
        };

        const updateMonsters = (damage) => {
            monsters.forEach(monster => {
                monster.accumulatedSpeed += monster.speed;
                while (monster.accumulatedSpeed >= 1) {
                    monster.y += 1;
                    monster.accumulatedSpeed -= 1;
                }
                monster.hp -= damage;
            });
            monsters = monsters.filter(monster => monster.hp > 0 && monster.y < 16);
        };

        const renderMonsters = () => {
            $('.monster').remove();

            monsters.forEach(monster => {
                let $monster;
                if (monster.type.shape === 'fire') {
                    $monster = $(createFireSVG()).addClass('monster');
                } else {
                    $monster = $('<div>')
                        .addClass('monster')
                        .css('background-color', monster.type.color);
                }

                $monster.css({
                    'grid-column': monster.x + 1,
                    'grid-row': Math.floor(monster.y) + 1
                });

                const $hpBar = $('<div>')
                    .addClass('hp-bar')
                    .css('width', `${monster.hp}%`);

                $monster.append($hpBar);
                $('#monster-area').append($monster);
            });
        };

        const updateLowestMonster = () => {
            if (monsters.length === 0) {
                $('#lowest-monster').text("가장 아래 몬스터: 없음");
            } else {
                const lowestMonster = monsters.reduce((lowest, current) => 
                    current.y > lowest.y ? current : lowest
                );
                $('#lowest-monster').text(`가장 아래 몬스터: (${lowestMonster.x}, ${Math.floor(lowestMonster.y)})`);
            }
        };

        const isMonsterGameOver = () => {
            return monsters.some(monster => monster.y >= 15);
        };

        const endGame = () => {
            isGameActive = false;
            $('#game-over').css({
                'display': 'flex',
                'position': 'absolute',
                'top': '50%',
                'left': '50%',
                'transform': 'translate(-50%, -50%)',
                'width': '400px',
                'height': '400px',
                'background-color': 'rgba(238, 228, 218, 0.73)',
                'z-index': '1000'
            }).show();
        };

        $(document).on('keydown', (event) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                event.preventDefault();
                if (isGameActive) {
                    move(event.key);
                }
            }
        });

        $('#restart').on('click', initGame);

        initGame();
    });
    </script>
</body>
</html>